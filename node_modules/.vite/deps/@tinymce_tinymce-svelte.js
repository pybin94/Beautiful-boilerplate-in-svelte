import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  attr_dev,
  binding_callbacks,
  createEventDispatcher,
  detach_dev,
  dispatch_dev,
  element,
  globals,
  init,
  insert_dev,
  noop,
  onDestroy,
  onMount,
  safe_not_equal,
  set_style,
  validate_slots
} from "./chunk-4NZVM4V3.js";

// node_modules/@tinymce/tinymce-svelte/dist/component/Utils.js
var validEvents = [
  "Activate",
  "AddUndo",
  "BeforeAddUndo",
  "BeforeExecCommand",
  "BeforeGetContent",
  "BeforeRenderUI",
  "BeforeSetContent",
  "BeforePaste",
  "Blur",
  "Change",
  "ClearUndos",
  "Click",
  "ContextMenu",
  "Copy",
  "Cut",
  "Dblclick",
  "Deactivate",
  "Dirty",
  "Drag",
  "DragDrop",
  "DragEnd",
  "DragGesture",
  "DragOver",
  "Drop",
  "ExecCommand",
  "Focus",
  "FocusIn",
  "FocusOut",
  "GetContent",
  "Hide",
  "Init",
  "KeyDown",
  "KeyPress",
  "KeyUp",
  "LoadContent",
  "MouseDown",
  "MouseEnter",
  "MouseLeave",
  "MouseMove",
  "MouseOut",
  "MouseOver",
  "MouseUp",
  "NodeChange",
  "ObjectResizeStart",
  "ObjectResized",
  "ObjectSelected",
  "Paste",
  "PostProcess",
  "PostRender",
  "PreProcess",
  "ProgressState",
  "Redo",
  "Remove",
  "Reset",
  "ResizeEditor",
  "SaveContent",
  "SelectionChange",
  "SetAttrib",
  "SetContent",
  "Show",
  "Submit",
  "Undo",
  "VisualAid"
];
var bindHandlers = (editor, dispatch) => {
  validEvents.forEach((eventName) => {
    editor.on(eventName, (e) => {
      dispatch(eventName.toLowerCase(), {
        eventName,
        event: e,
        editor
      });
    });
  });
};

// node_modules/@tinymce/tinymce-svelte/dist/component/Editor.svelte
var { Object: Object_1 } = globals;
var file = "node_modules/@tinymce/tinymce-svelte/dist/component/Editor.svelte";
function create_else_block(ctx) {
  let textarea;
  const block = {
    c: function create() {
      textarea = element("textarea");
      attr_dev(
        textarea,
        "id",
        /*id*/
        ctx[0]
      );
      set_style(textarea, "visibility", "hidden");
      add_location(textarea, file, 130, 2, 4109);
    },
    m: function mount(target, anchor) {
      insert_dev(target, textarea, anchor);
      ctx[18](textarea);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*id*/
      1) {
        attr_dev(
          textarea,
          "id",
          /*id*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[18](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(130:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(
        div,
        "id",
        /*id*/
        ctx[0]
      );
      add_location(div, file, 128, 2, 4059);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      ctx[17](div);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*id*/
      1) {
        attr_dev(
          div,
          "id",
          /*id*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[17](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(128:0) {#if inline}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  function select_block_type(ctx2, dirty) {
    if (/*inline*/
    ctx2[1])
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      attr_dev(
        div,
        "class",
        /*cssClass*/
        ctx[2]
      );
      add_location(div, file, 126, 0, 3999);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if_block.m(div, null);
      ctx[19](div);
    },
    p: function update(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(div, null);
        }
      }
      if (dirty & /*cssClass*/
      4) {
        attr_dev(
          div,
          "class",
          /*cssClass*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if_block.d();
      ctx[19](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var uuid = (prefix) => {
  return prefix + "_" + Math.floor(Math.random() * 1e9) + String(Date.now());
};
var createScriptLoader = () => {
  let state = {
    listeners: [],
    scriptId: uuid("tiny-script"),
    scriptLoaded: false,
    injected: false
  };
  const injectScript = (scriptId, doc, url, cb) => {
    state.injected = true;
    const script = doc.createElement("script");
    script.referrerPolicy = "origin";
    script.type = "application/javascript";
    script.src = url;
    script.onload = () => {
      cb();
    };
    if (doc.head)
      doc.head.appendChild(script);
  };
  const load = (doc, url, callback) => {
    if (state.scriptLoaded) {
      callback();
    } else {
      state.listeners.push(callback);
      if (!state.injected) {
        injectScript(state.scriptId, doc, url, () => {
          state.listeners.forEach((fn) => fn());
          state.scriptLoaded = true;
        });
      }
    }
  };
  return { load };
};
var scriptLoader = createScriptLoader();
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Editor", slots, []);
  var _a;
  let { id = uuid("tinymce-svelte") } = $$props;
  let { inline = void 0 } = $$props;
  let { disabled = false } = $$props;
  let { apiKey = "no-api-key" } = $$props;
  let { channel = "6" } = $$props;
  let { scriptSrc = void 0 } = $$props;
  let { conf = {} } = $$props;
  let { modelEvents = "change input undo redo" } = $$props;
  let { value = "" } = $$props;
  let { text = "" } = $$props;
  let { cssClass = "tinymce-wrapper" } = $$props;
  let container;
  let element2;
  let editorRef;
  let lastVal = value;
  let disablindCache = disabled;
  const dispatch = createEventDispatcher();
  const getTinymce = () => {
    const getSink = () => {
      return typeof window !== "undefined" ? window : global;
    };
    const sink = getSink();
    return sink && sink.tinymce ? sink.tinymce : null;
  };
  const init2 = () => {
    const finalInit = Object.assign(Object.assign({}, conf), {
      target: element2,
      inline: inline !== void 0 ? inline : conf.inline !== void 0 ? conf.inline : false,
      readonly: disabled,
      setup: (editor) => {
        $$invalidate(14, editorRef = editor);
        editor.on("init", () => {
          editor.setContent(value);
          editor.on(modelEvents, () => {
            $$invalidate(15, lastVal = editor.getContent());
            if (lastVal !== value) {
              $$invalidate(5, value = lastVal);
              $$invalidate(6, text = editor.getContent({ format: "text" }));
            }
          });
        });
        bindHandlers(editor, dispatch);
        if (typeof conf.setup === "function") {
          conf.setup(editor);
        }
      }
    });
    $$invalidate(4, element2.style.visibility = "", element2);
    getTinymce().init(finalInit);
  };
  onMount(() => {
    if (getTinymce() !== null) {
      init2();
    } else {
      const script = scriptSrc ? scriptSrc : `https://cdn.tiny.cloud/1/${apiKey}/tinymce/${channel}/tinymce.min.js`;
      scriptLoader.load(container.ownerDocument, script, () => {
        init2();
      });
    }
  });
  onDestroy(() => {
    var _a2;
    if (editorRef) {
      (_a2 = getTinymce()) === null || _a2 === void 0 ? void 0 : _a2.remove(editorRef);
    }
  });
  const writable_props = [
    "id",
    "inline",
    "disabled",
    "apiKey",
    "channel",
    "scriptSrc",
    "conf",
    "modelEvents",
    "value",
    "text",
    "cssClass"
  ];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Editor> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(3, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("inline" in $$props2)
      $$invalidate(1, inline = $$props2.inline);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
    if ("apiKey" in $$props2)
      $$invalidate(8, apiKey = $$props2.apiKey);
    if ("channel" in $$props2)
      $$invalidate(9, channel = $$props2.channel);
    if ("scriptSrc" in $$props2)
      $$invalidate(10, scriptSrc = $$props2.scriptSrc);
    if ("conf" in $$props2)
      $$invalidate(11, conf = $$props2.conf);
    if ("modelEvents" in $$props2)
      $$invalidate(12, modelEvents = $$props2.modelEvents);
    if ("value" in $$props2)
      $$invalidate(5, value = $$props2.value);
    if ("text" in $$props2)
      $$invalidate(6, text = $$props2.text);
    if ("cssClass" in $$props2)
      $$invalidate(2, cssClass = $$props2.cssClass);
  };
  $$self.$capture_state = () => ({
    _a,
    uuid,
    createScriptLoader,
    scriptLoader,
    _a,
    onMount,
    createEventDispatcher,
    onDestroy,
    bindHandlers,
    id,
    inline,
    disabled,
    apiKey,
    channel,
    scriptSrc,
    conf,
    modelEvents,
    value,
    text,
    cssClass,
    container,
    element: element2,
    editorRef,
    lastVal,
    disablindCache,
    dispatch,
    getTinymce,
    init: init2
  });
  $$self.$inject_state = ($$props2) => {
    if ("_a" in $$props2)
      $$invalidate(13, _a = $$props2._a);
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("inline" in $$props2)
      $$invalidate(1, inline = $$props2.inline);
    if ("disabled" in $$props2)
      $$invalidate(7, disabled = $$props2.disabled);
    if ("apiKey" in $$props2)
      $$invalidate(8, apiKey = $$props2.apiKey);
    if ("channel" in $$props2)
      $$invalidate(9, channel = $$props2.channel);
    if ("scriptSrc" in $$props2)
      $$invalidate(10, scriptSrc = $$props2.scriptSrc);
    if ("conf" in $$props2)
      $$invalidate(11, conf = $$props2.conf);
    if ("modelEvents" in $$props2)
      $$invalidate(12, modelEvents = $$props2.modelEvents);
    if ("value" in $$props2)
      $$invalidate(5, value = $$props2.value);
    if ("text" in $$props2)
      $$invalidate(6, text = $$props2.text);
    if ("cssClass" in $$props2)
      $$invalidate(2, cssClass = $$props2.cssClass);
    if ("container" in $$props2)
      $$invalidate(3, container = $$props2.container);
    if ("element" in $$props2)
      $$invalidate(4, element2 = $$props2.element);
    if ("editorRef" in $$props2)
      $$invalidate(14, editorRef = $$props2.editorRef);
    if ("lastVal" in $$props2)
      $$invalidate(15, lastVal = $$props2.lastVal);
    if ("disablindCache" in $$props2)
      $$invalidate(16, disablindCache = $$props2.disablindCache);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*editorRef, lastVal, value, disabled, disablindCache, _a*/
    123040) {
      $: {
        if (editorRef && lastVal !== value) {
          editorRef.setContent(value);
          $$invalidate(6, text = editorRef.getContent({ format: "text" }));
        }
        if (editorRef && disabled !== disablindCache) {
          $$invalidate(16, disablindCache = disabled);
          if (typeof ($$invalidate(13, _a = editorRef.mode) === null || _a === void 0 ? void 0 : _a.set) === "function") {
            editorRef.mode.set(disabled ? "readonly" : "design");
          } else {
            editorRef.setMode(disabled ? "readonly" : "design");
          }
        }
      }
    }
  };
  return [
    id,
    inline,
    cssClass,
    container,
    element2,
    value,
    text,
    disabled,
    apiKey,
    channel,
    scriptSrc,
    conf,
    modelEvents,
    _a,
    editorRef,
    lastVal,
    disablindCache,
    div_binding,
    textarea_binding,
    div_binding_1
  ];
}
var Editor = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      id: 0,
      inline: 1,
      disabled: 7,
      apiKey: 8,
      channel: 9,
      scriptSrc: 10,
      conf: 11,
      modelEvents: 12,
      value: 5,
      text: 6,
      cssClass: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Editor",
      options,
      id: create_fragment.name
    });
  }
  get id() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inline() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inline(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get apiKey() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set apiKey(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get channel() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set channel(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scriptSrc() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scriptSrc(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get conf() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set conf(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get modelEvents() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set modelEvents(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get cssClass() {
    throw new Error("<Editor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set cssClass(value) {
    throw new Error("<Editor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Editor_default = Editor;

// node_modules/@tinymce/tinymce-svelte/dist/index.js
var dist_default = Editor_default;
export {
  dist_default as default
};
//# sourceMappingURL=@tinymce_tinymce-svelte.js.map
